---
title: "How to Handle Multiple Yocto Meta Layers with repo"
date: 2025-07-15T20:44:22+02:00
draft: true
---

= Yocto and its multiple layers

Yocto has layers, like Ogres and onions. Each layer brings a new set of tools, functions or confiugration to the table. A custom image usually means putting together a whole stack of them, five, ten, or even more layers. Keeping all of them in sync? That's where things can get messy, unless the right tools are used.

== Keep the layers in sync, but why?

The meta-layers of Yocto are complex constructs - each one has multiple branches, typically one per Yocto release, and each branch comes with a shitload of commits. In practice, only the LTS (long term support) and actively maintained branches receive ongoing updates. At the moment, the LTS Yocto releases are Kirkstone (until Apr. 2026) and Scarthgap (util April 2026).

When assembling a custom distribution, it's essential to treat the layer setup as a consistent snapshot in time, all layers should be pinned to compatible commits from the same release branch and roughly the same point in time.

== Introducing: repo

The solution to the synchronization problem is called `repo` - a repository management tool build on top of **Git**. Similar to `git` submodules, repo can fetch specific branches and commits of multiple meta-layers, and does all of it based on a configuration file __manifest.xml__. https://gerrit.googlesource.com/git-repo[`repo`] was created by *Google* to help with the management of the Android and Yocto repositories and slowly is becoming the standard tool for putting Yocto distributions together. Many popular vendors like https://github.com/nxp-imx/imx-manifest[NXP] or STM already use it.

=== Install Instructions

`repo` is a python script at it's core and can be installed as such, simply by downloading a single file from google. The script will later take care of creating a repo envinronment by fetching the rest of the resources.

[bash]
----
# manual install
mkdir -p ~/.bin
PATH="${HOME}/.bin:${PATH}"
curl https://storage.googleapis.com/git-repo-downloads/repo > ~/.bin/repo
chmod a+rx ~/.bin/repo
----

That's not the only option though. `repo` is available in most of the package managers of the popular Linux distributions.

**Debian / Ubuntu**

[bash]
----
sudo apt-get install repo
----

**Gentoo**
[bash]
----
sudo emerge dev-vcs/repo
----

=== Repo Manifest

Previously mentioned repo **manifest** file is the base for the creation of a Yocto distribution. Repo requires the manifest to be hosted in a git repository, moreover, a usual good practice is to follow the Yocto versioning with branch naming in the manifest project. 

For the purpose of this blog and to exercise the `repo` skills, I made a simple project on github with a manifest for raspberry-pi distribution - https://github.com/anthonio9/rpi-manifest[rpi-manifest]. The rest of the article follows the process of putting together a functional manifest file.

**Synthax and Structure**

Manifests are always **XML** files. Are you thinking messy tags and never ending indentations? Well, that should not be the case here, as the indentations are rather shallow, but tags are real and it's possible to use them efficiently. The manifest starts with a line stating the XML version and enconding - standard XML stuff:

----
<?xml version="1.0" encoding="UTF-8"?>
----

then, the tag opening the manifest meta-layer configuration follows

----
<manifest>
# manifest content goes here
</manifest>
----

repo manifest files have a synthax rich in keywords like _revision_, _remote_, _fetch_, _path_, _project_ and a few more, which are described in detail in the https://gerrit.googlesource.com/git-repo/+/HEAD/docs/manifest-format.md[Manifest Format documentation] provided by Google. As this article is based on my own work experience, only the synthax options I have personally used are introduced below. 

**Remote**

The tag `remote` assigns a name to a git URL. Intuitively, the name is set with `name` attribute, and the URL with `fetch`. The URL should be a path to the mother project, or a group which members are specified further down with the `project` tags. 

----
<remote name="yp"          fetch="https://git.yoctoproject.org"/>
----

**Project**

`project` tag describes a git repository to be cloned. A few attributes go along with it, to provide the detailed info about how the repository should be cloned.

* `name` - name of the git project. The value of this attribute is appended to the URL specified in the `remote` attribute, followed by _.git_.
* `remote` - the parent URL of the requested git project. This could be either the group URL or user main workspace, just like in the `remote` tag. What's more is that the `remote` tags can be referenced here, by passing the `remote` tag `name` value, this is later expanded into the full URL.
* `path` - the destination path of the cloned project, the path is relative to the top directory of the repo client
* `revision` - name of the Git branch the manifest wants to track for this project, a commit hash should also work.
* `upstream` - 

**Linkfile**

`linkfile` tag lives inside of the manifest tags and is used to specify symbolic linking to the files provided by the project. The file location in the source git repository is set with `src` attribute and the target location in the local filetree is specified with `dest` attribute. Both paths are relative. A single `project` tag may be a home to multiple `linkfile` tags.


